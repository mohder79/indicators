# -*- coding: utf-8 -*-
"""slope.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qa46Jp2kphnIJMzFG__Nb_PWbSnHw5DK

How to calculate slope ? 

https://www.archtoolbox.com/calculating-slope/

library we use:

https://scipy.org/

pip install scipy
"""

# install lib we need
! pip install scipy
! pip install pandas 
! pip install plotly
! pip install ccxt

# { import libraries
import ccxt
from datetime import datetime
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from scipy.stats import linregress
# }

# { load exchange to get data
exchange = ccxt.binance({
    'options': {
        'adjustForTimeDifference': True,
    },

})
# }

# { load data as function
def fetch(symbol: str, timeframe: str, limit: int):
    print(f"Fetching {symbol} new bars for {datetime.now().isoformat()}")

    bars = exchange.fetch_ohlcv(
        symbol, timeframe=timeframe, limit=limit)  # fetch ohlcv
    df = pd.DataFrame(bars[:-1], columns=['timestamp',
                      'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    #df = df.set_index(pd.DatetimeIndex(df.timestamp))
    return df
# }

# { set symbol for data function
BTC = fetch('BTC/USDT', '4h', 1000)
# }

# print data
BTC

# { function to calculate sma
def SMA(data: str, length: int, column: str):
    return data[column].rolling(window=length).mean()
# }

BTC['sma'] = SMA(BTC, 20, 'close')  # use function for  calculate sma

BTC['sma'] #print sma

# { function to calculate EMA 
def EMA(data: str, src: str, Length: int, smoothing=2):
    EMA = np.zeros(np.size(data[src]))
    emasize = np.size(data[src])
    EMA[:Length-1] = np.NaN
    EMA[Length-1] = np.mean(data[src][:Length])
    for i in range(Length, emasize):
        EMA[i] = (((smoothing/(Length + 1)) * data[src][i]) +
                  ((1-(smoothing/(Length + 1))) * EMA[i-1]))
    return np.round(EMA, 2)
# }

BTC['ema'] = EMA(BTC, 'close', 20)  # use function to calculate ema 

BTC['ema'] #print ema

# set src and len to calculate slpoe

src = 'sma' # also use ema or ohlc 
len = 4 # back data to calculate slop

#{ function to calculate slope
def SLOPE(src:str = src , len:int =len ,data:str = BTC):
  return data[src].rolling(len).apply(lambda s: linregress(s.reset_index())[0])

BTC['slope'] = SLOPE() # use function to calculate slope 

BTC['slope'] #print slope

# { plot data
fig = make_subplots(rows=2, cols=1, shared_xaxes=True)

fig.add_trace(go.Candlestick(x=BTC.index,
                             open=BTC['open'],
                             high=BTC['high'],
                             low=BTC['low'],
                             close=BTC['close'],
                             showlegend=False))
fig.add_trace(go.Scatter(x=BTC.index,
                         y=BTC['slope'],
                         opacity=0.7,
                         line=dict(color='Gray', width=2),
                         name='slope'), row=2, col=1)
fig.show()
# }

#change slope color whit condition for ploting
BTC['slope_avg'] = BTC['slope'].rolling(window=len).mean()
BTC['long']=np.where((BTC['slope'] > 0 ) & (BTC['slope'] > BTC['slope_avg'] ) ,BTC['slope'] , np.nan )
BTC['short']=np.where((BTC['slope'] < 0 ) & (BTC['slope'] < BTC['slope_avg'] ) ,BTC['slope'] , np.nan )

BTC

# { plot data
fig = make_subplots(rows=2, cols=1, shared_xaxes=True)

fig.add_trace(go.Candlestick(x=BTC.index,
                             open=BTC['open'],
                             high=BTC['high'],
                             low=BTC['low'],
                             close=BTC['close'],
                             showlegend=False))

fig.add_trace(go.Scatter(x=BTC.index,
                         y=BTC['long'],
                         opacity=1,
                         line=dict(color='green', width=2),
                         name='slope'), row=2, col=1)

fig.add_trace(go.Scatter(x=BTC.index,
                         y=BTC['short'],
                         opacity=1,
                         line=dict(color='red', width=2),
                         name='slopee'), row=2, col=1)

fig.add_trace(go.Scatter(x=BTC.index,
                         y=BTC['slope'],
                         opacity=0.4,
                         line=dict(color='Gray', width=2),
                         name='slope'), row=2, col=1)

# }

fig.show()